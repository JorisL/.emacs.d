#+TITLE: DotEmacs
#+PROPERTY: header-args :results silent

* Initializers
Set debugger information.
#+begin_src emacs-lisp
  (setq debug-on-error t)
  (setq byte-compile-debug t)
  (setq debug-on-quit t)
#+end_src

Load the "Garbage Collection Magic Hack".
#+begin_src emacs-lisp
  (use-package gcmh
    :ensure t
    :init
    (gcmh-mode 1))
#+end_src

* Helper functions / definitions
These are some functions / defenitions used for this config.
#+begin_src emacs-lisp
  (defconst IS-MAC     (eq system-type 'darwin))
  (defconst IS-LINUX   (eq system-type 'gnu/linux))
  (defconst IS-WINDOWS (memq system-type '(cygwin windows-nt ms-dos)))
  (defconst IS-BSD     (or IS-MAC (eq system-type 'berkeley-unix)))
#+end_src

Unix tools look for HOME, but this is normally not defined on Windows.

#+begin_src emacs-lisp
  (when (and IS-WINDOWS (null (getenv-internal "HOME")))
    (setenv "HOME" (getenv "USERPROFILE"))
    (setq abbreviated-home-dir nil))
#+end_src

Setup the emacs path such that it is the same as the system shell
#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :config
    (exec-path-from-shell-initialize))
#+end_src

* Generic Emacs settings
** Server
#+begin_src emacs-lisp
  (require 'server)
  (unless (server-running-p)
    (server-start))
#+end_src

** Optimizations
Note: most of these optimizations are taken from [[https://github.com/hlissner/doom-emacs/][doom emacs]] (core.el).

Speed up startup by increasing garbage collection treshhold during startup
#+begin_src emacs-lisp
  (defvar default-file-name-handler-alist file-name-handler-alist)
  (setq file-name-handler-alist nil)
  (setq gc-cons-threshold 80000000)
  (add-hook 'emacs-startup-hook
            (lambda ()
              "Restore defalut values after init."
              (setq file-name-handler-alist default-file-name-handler-alist)
              (setq gc-cons-threshold 800000)
              (if (boundp 'after-focus-change-function)
                  (add-function :after after-focus-change-function
                                (lambda ()
                                  (unless (frame-focus-state)
                                    (garbage-collect))))
                (add-hook 'after-focus-change-function 'garbage-collect))))
#+end_src

A second, case-insensitive pass over `auto-mode-alist' is time wasted,
and indicates misconfiguration (or that the user needs to stop relying on case insensitivity).
#+begin_src emacs-lisp
  (setq auto-mode-case-fold nil)
#+end_src

Disable bidirectional text rendering for a modest performance boost.
I've set this to `nil' in the past, but the `bidi-display-reordering's docs say
that is an undefined state and suggest this to be just as good:
#+begin_src emacs-lisp
  (setq-default bidi-display-reordering 'left-to-right
                bidi-paragraph-direction 'left-to-right)
#+end_src

Disabling the BPA makes redisplay faster, but might produce incorrect display
reordering of bidirectional text with embedded parentheses and other bracket
characters whose 'paired-bracket' Unicode property is non-nil.
#+begin_src emacs-lisp
  (setq bidi-inhibit-bpa t)  ; Emacs 27 only
#+end_src

More performant rapid scrolling over unfontified regions.
May cause brief spells of inaccurate syntax highlighting right after scrolling,
which should quickly self-correct.
#+begin_src emacs-lisp
  (setq fast-but-imprecise-scrolling t)
#+end_src

Reduce rendering/line scan work for Emacs by not rendering cursors or regions in non-focused windows.
#+begin_src emacs-lisp
  (setq-default cursor-in-non-selected-windows nil)
  (setq highlight-nonselected-windows nil)
#+end_src

Emacs "updates" its ui more often than it needs to, so we slow it down slightly from 0.5s:
#+begin_src emacs-lisp
  (setq idle-update-delay 1.0)
#+end_src

Font compacting can be terribly expensive, especially for rendering icon fonts on Windows.
Whether disabling it has a notable affect on Linux and Mac hasn't been determined,
but we inhibit it there anyway.
This increases memory usage, however!
#+begin_src emacs-lisp
  (setq inhibit-compacting-font-caches t)
#+end_src

Performance on Windows is considerably worse than elsewhere.
We'll need everything we can get.
#+begin_src emacs-lisp
;  (when IS-WINDOWS
;    (setq w32-get-true-file-attributes nil   ; decrease file IO workload
;          w32-pipe-read-delay 0              ; faster ipc
;          w32-pipe-buffer-size (* 64 1024))) ; read more at a time (was 4K)
#+end_src

Remove command line options that aren't relevant to our current OS;
means slightly less to process at startup.
#+begin_src emacs-lisp
  (unless IS-MAC   (setq command-line-ns-option-alist nil))
  (unless IS-LINUX (setq command-line-x-option-alist nil))
#+end_src

** Better defaults
Here are some better default settings

#+BEGIN_SRC emacs-lisp
  (setq-default
   ad-redefinition-action 'accept         ; Silence warnings for redefinition
   auto-save-list-file-prefix nil         ; Prevent tracking for auto-saves
   cursor-in-non-selected-windows nil     ; Hide the cursor in inactive windows
   cursor-type 'bar                       ; Prefer a bar-shaped cursor
   custom-unlispify-menu-entries nil      ; Prefer kebab-case for titles
   custom-unlispify-tag-names nil         ; Prefer kebab-case for symbols
   delete-by-moving-to-trash t            ; Delete files to trash
   fill-column 120                        ; Set width for automatic line breaks
   help-window-select t                   ; Focus new help windows when opened
   indent-tabs-mode nil                   ; Stop using tabs to indent
   inhibit-startup-screen t               ; Disable start-up screen
   initial-scratch-message ""             ; Empty the initial *scratch* buffer
   mouse-yank-at-point t                  ; Yank at point rather than pointer
   recenter-positions '(5 top bottom)     ; Set re-centering positions
   scroll-conservatively 101              ; Avoid recentering when scrolling far
   scroll-margin 2                        ; Add a margin when scrolling vertically
   select-enable-clipboard t              ; Merge system's and Emacs' clipboard
   sentence-end-double-space nil          ; Use a single space after dots
   tab-width 4                            ; Set width for tabs
   uniquify-buffer-name-style 'forward    ; Uniquify buffer names
   window-combination-resize t            ; Resize windows proportionally
   window-divider-default-right-width 2   ; Thin window vertical dividers
   global-auto-revert-non-file-buffers t  ; Auto refresh dired buffers
   auto-revert-verbose nil                ; Be silent when dired auto-refreshes
   x-stretch-cursor t)                    ; Stretch cursor to the glyph width
  (delete-selection-mode 1)               ; Replace region when inserting text
  (fset 'yes-or-no-p 'y-or-n-p)           ; Replace yes/no prompts with y/n
  (global-subword-mode 1)                 ; Iterate through CamelCase words
  (tool-bar-mode 0)                       ; Disable the tool bar
  (mouse-avoidance-mode 'exile)           ; Avoid collision of mouse with point
  (put 'downcase-region 'disabled nil)    ; Enable downcase-region
  (put 'upcase-region 'disabled nil)      ; Enable upcase-region
  (global-auto-revert-mode t)             ; Auto reload files from disk
  (setq tab-always-indent 'complete)      ; When pressin <Tab> first try to indent; complete if already indented
#+END_SRC

Use =.emacscache/= to contain local data. This is to avoid littering in the Emacs
directory with an ever-growing number of packages used on a daily basis.

#+BEGIN_SRC emacs-lisp
  (defconst me/cache-directory
    (expand-file-name ".emacscache/")
    "Directory where all cache files should be saved")

  (defun me/cache-concat (name)
    "Return the absolute path of NAME under `me/cache-directory'."
    (let ((directory (file-name-as-directory me/cache-directory)))
      (make-directory directory t)
      (convert-standard-filename (concat directory name))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'request
    (setq-default request-storage-directory (me/cache-concat "request/")))
  (with-eval-after-load 'tramp
    (setq-default tramp-persistency-file-name (me/cache-concat "tramp")))
  (with-eval-after-load 'url
    (setq-default url-configuration-directory (me/cache-concat "url/")))
#+END_SRC

On  also use ⌘ as =meta=.
#+BEGIN_SRC emacs-lisp
  (setq mac-command-modifier 'meta)
#+END_SRC

Always use unicode:
#+begin_src emacs-lisp
  (set-charset-priority 'unicode)
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
  (setq default-process-coding-system '(utf-8-unix . utf-8-unix))
#+end_src

...
#+begin_src emacs-lisp
  (delete-selection-mode t)
  (global-display-line-numbers-mode t)
  (column-number-mode)
#+end_src

Highlight current line, but only when in text or programming mode
#+begin_src emacs-lisp
  (require 'hl-line)
  (add-hook 'prog-mode-hook #'hl-line-mode)
  (add-hook 'text-mode-hook #'hl-line-mode)
  (set-face-attribute 'hl-line nil :background "gray21")
#+end_src

Emacs is super fond of littering filesystems with backups and autosaves,
since it was built with the assumption that multiple users could be using the same Emacs instance on the same filesystem. 
This was valid in 1980. It is no longer the case.
#+begin_src emacs-lisp
  (setq
   make-backup-files nil
   auto-save-default nil
   create-lockfiles nil)
#+end_src

...
#+begin_src emacs-lisp
  ;(electric-pair-mode)
  ;; disable <> auto pairing in electric-pair-mode for org-mode
  ;(add-hook
  ; 'org-mode-hook
  ; (lambda ()
  ;   (setq-local electric-pair-inhibit-predicate
  ;               `(lambda (c)
  ;                  (if (char-equal c ?<) t (,electric-pair-inhibit-predicate c))))))
#+end_src

#+begin_src emacs-lisp
  (defvar show-paren-delay 0) 
  (show-paren-mode 1)
#+end_src

** Load secrets
Load secrets (or other things that shouldn't be included in version control) from =.secrets.el=.
This is also where machine specific settings should be stored.

The variables over here are default values for when they aren't defined in =.secrets.el=.
Use the ~(setq variable value)~ syntax in that file, since the variable is already initialized over here.

#+BEGIN_SRC emacs-lisp
  (defvar me/erc-nick           nil       "The ERC nick to use.")
  (defvar me/erc-password       nil       "The ERC password to use.")
  (defvar me/erc-port           nil       "The ERC port to use.")
  (defvar me/erc-server         nil       "The ERC server to use.")
  (defvar me/font-family        "Monaco"  "The font to use.")
  (defvar me/font-size-default  120       "The font size to use for default text.")
  (defvar me/font-size-large    1.2       "The font size to use for larger text.")
  (defvar me/font-size-small    .8        "The font size to use for smaller text.")

  (setq org-directory "~/org")
  (defvar me/org-roam-directory "~/org/roam")

  (let ((secrets.el (expand-file-name ".secrets.el")))
    (load secrets.el t))
#+END_SRC

** Theme
Configure [[https://protesilaos.com/emacs/modus-themes][modus vivendi]] theme.
This theme is chosen since it has a good contrast between elements,
and because it has many settings to improve accesability (e.g. to help with deuteranopia).

Remark: theme will be included by default in emacs 28.
For info on the theme, execute (info "(modus-themes) Top")

#+begin_src emacs-lisp
  (use-package modus-themes
    :ensure t
    :init
    ;; Add all your customizations prior to loading the themes
    (setq modus-themes-deuteranopia t
          modus-themes-italic-constructs t
          modus-themes-syntax '(green-strings yellow-comments alt-syntax)
          modus-themes-subtle-line-numbers t
          modus-themes-intense-markup t
          modus-themes-paren-match '(intense underline)
          modus-themes-org-blocks 'gray-background)

    ;; Load the theme files before enabling a theme (else you get an error).
    (modus-themes-load-themes)
    :config
    ;; Load the theme of your choice:
    (modus-themes-load-vivendi)
    :bind ("<f7>" . modus-themes-toggle))
#+end_src

** God mode
[[https://github.com/emacsorphanage/god-mode][God mode]] is used to get modal editing with regular emacs keybindings.
When god mode is enabled you dont have to chord Ctrl/Meta.
As an example: =xs= becomes =C-x C-s=.
By default all pressed keys are combined with Ctrl, but by first pressing =g= it is changed to Meta.
For example: =gx= becomes =M-x=.
The mode can be toggled using =Esc=.

#+BEGIN_SRC emacs-lisp
  (use-package god-mode
    :ensure t
    :bind (("<escape>" . god-mode-all)
           ("C-x C-1" . delete-other-windows)
           ("C-x C-2" . split-window-below)
           ("C-x C-3" . split-window-right)
           ("C-x C-0" . delete-window)))
  :config
  (defun my-god-mode-update-cursor ()
    (setq cursor-type (if (or god-local-mode buffer-read-only)
                          'box
                        'bar)))
  (add-hook 'god-mode-enabled-hook #'my-god-mode-update-cursor)
  (add-hook 'god-mode-disabled-hook #'my-god-mode-update-cursor)
  (define-key god-local-mode-map (kbd "z") #'repeat)
                                          ;(define-key god-local-mode-map (kbd "i") #'god-local-mode)
#+END_SRC

** isearch
Set arrow keys in isearch. left/right is backward/forward ,up/down is history. press Return to exit
#+begin_src emacs-lisp
  (progn
    (define-key isearch-mode-map (kbd "<up>") 'isearch-ring-retreat )
    (define-key isearch-mode-map (kbd "<down>") 'isearch-ring-advance )

    (define-key isearch-mode-map (kbd "<left>") 'isearch-repeat-backward)
    (define-key isearch-mode-map (kbd "<right>") 'isearch-repeat-forward)

    (define-key minibuffer-local-isearch-map (kbd "<left>") 'isearch-reverse-exit-minibuffer)
    (define-key minibuffer-local-isearch-map (kbd "<right>") 'isearch-forward-exit-minibuffer)

    (define-key isearch-mode-map (kbd "C-v") 'avy-isearch))
#+end_src
** STARTED Embark
Context menu for current selection (also integrates nicely with avy)

#+begin_src emacs-lisp
  (use-package embark
    :ensure t
    :config  :bind
    (("M-." . embark-act)          ;; pick some comfortable binding
     ("C-;" . embark-dwim)         ;; 
     ("C-h B" . embark-bindings))) ;; alternative for `describe-bindings')
#+end_src

** STARTED Avy
Jump to, or perform actions, on part of text on screen by typing its first characters.

#+begin_src emacs-lisp
  (use-package avy
    :ensure t
    :config
    (avy-setup-default)
    ;; Revind C-v (scroll-up-command) since I never use it,
    ;; and since it's one of the easier commands to do without leaving home row.
    ;; (especially when TAB/CAPS lock maps to CTRL when held)
    (global-set-key (kbd "C-v") 'avy-goto-char-timer)
    (global-set-key (kbd "C-c C-j") 'avy-resume)

    (setq avy-style 'pre)

    ;; Kill text
    (defun avy-action-kill-whole-line (pt)
      (save-excursion
        (goto-char pt)
        (kill-whole-line))
      (select-window
       (cdr
        (ring-ref avy-ring 0)))
      t)

    (setf (alist-get ?k avy-dispatch-alist) 'avy-action-kill-stay
          (alist-get ?K avy-dispatch-alist) 'avy-action-kill-whole-line)

    ;; Copy text
    (defun avy-action-copy-whole-line (pt)
      (save-excursion
        (goto-char pt)
        (cl-destructuring-bind (start . end)
            (bounds-of-thing-at-point 'line)
          (copy-region-as-kill start end)))
      (select-window
       (cdr
        (ring-ref avy-ring 0)))
      t)

    (setf (alist-get ?w avy-dispatch-alist) 'avy-action-copy
          (alist-get ?W avy-dispatch-alist) 'avy-action-copy-whole-line)

    ;; Yank text
    (defun avy-action-yank-whole-line (pt)
      (avy-action-copy-whole-line pt)
      (save-excursion (yank))
      t)

    (setf (alist-get ?y avy-dispatch-alist) 'avy-action-yank
          (alist-get ?Y avy-dispatch-alist) 'avy-action-yank-whole-line)

    ;; Transpose/Move text
    (defun avy-action-teleport-whole-line (pt)
      (avy-action-kill-whole-line pt)
      (save-excursion (yank)) t)

    (setf (alist-get ?t avy-dispatch-alist) 'avy-action-teleport
          (alist-get ?T avy-dispatch-alist) 'avy-action-teleport-whole-line)

    ;; Mark text
    (defun avy-action-mark-to-char (pt)
      (activate-mark)
      (goto-char pt))

    (setf (alist-get ?  avy-dispatch-alist) 'avy-action-mark-to-char)

    ;; Embark
    (defun avy-action-embark (pt)
      (unwind-protect
          (save-excursion
            (goto-char pt)
            (embark-act))
        (select-window
         (cdr (ring-ref avy-ring 0))))
      t)

    (setf (alist-get ?. avy-dispatch-alist) 'avy-action-embark))
#+end_src

** Custom keybindings
Map =comment-line= (normally =C-x C-;=) to =C-;=.
This is especially usefull with god-mode
#+begin_src emacs-lisp
  (global-set-key (kbd "C-;") 'comment-line)
#+end_src

Map =apply-macro-to-region-lines= to =<f5>= (key is normally unmapped,
and is right next to =<f3>= and =<f4>= which are already used for recording/replaying macro's)
#+begin_src emacs-lisp
  (global-set-key (kbd "<f5>") 'apply-macro-to-region-lines)
#+end_src

Define function to duplicate an entire line, and map it to =<C-d>=.
This is normally bound to =delete-char= (delete key).
After this has been defined, the =delete-char= has to be bound back to the =<delete>= key
(otherwise delete will also run this new duplicate function). 
#+begin_src emacs-lisp
  (defun duplicate-line()
    (interactive)
    (move-beginning-of-line 1)
    (kill-line)
    (yank)
    (open-line 1)
    (forward-line 1)
    (yank)
  )
  (global-set-key (kbd "C-d") 'duplicate-line)
  (global-set-key (kbd "<delete>") 'delete-char)
#+end_src

** Command completion
Use =vertico= as lightweight command completion tool (shown when using =C-x C-f=, =C-x b=, etc.).
=Savehist= is used to show the listed items based on historical usage.
=Marginalia= shows additional info on the right of the minibuffer (example: in file select mode it shows the size, modification date, etc.).

#+begin_src emacs-lisp
(use-package vertico
  :ensure t
  :bind (:map vertico-map
         ("C-j" . vertico-next)
         ("C-k" . vertico-previous)
         ("C-f" . vertico-exit)
         :map minibuffer-local-map
         ("M-h" . backward-kill-word))
  :custom
  (vertico-cycle t)
  :init
  (vertico-mode))

(use-package savehist
  :init
  (savehist-mode))

(use-package marginalia
  :after vertico
  :ensure t
  :custom
  (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
  :init
  (marginalia-mode))
#+end_src

Configure some build-in emacs settings to have better minibuffer completion, which is therefore also used by =vertico=). E.g. fuzzy matching, regex, etc.. 
#+begin_src emacs-lisp
  (setq read-file-name-completion-ignore-case t
        read-buffer-completion-ignore-case t
        completion-cycle-threshold 10
        completion-styles '(initials partial-completion flex)
        completion-ignore-case t)
#+end_src

Add additional sources for completion using =consult=.
#+begin_src emacs-lisp
  (use-package consult
    :ensure t
    ;; Replace bindings. Lazily loaded due by `use-package'.
    :bind (;; C-c bindings (mode-specific-map)
           ;("C-c h" . consult-history)
           ;("C-c m" . consult-mode-command)
           ;("C-c b" . consult-bookmark)
           ;("C-c k" . consult-kmacro)
           ;; C-x bindings (ctl-x-map)
           ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
           ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
           ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
           ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
           ;; Custom M-# bindings for fast register access
           ("M-#" . consult-register-load)
           ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
           ("C-M-#" . consult-register)
           ;; Other custom bindings
           ("M-y" . consult-yank-pop)                ;; orig. yank-pop
           ("<help> a" . consult-apropos)            ;; orig. apropos-command
           ;; M-g bindings (goto-map)
           ("M-g e" . consult-compile-error)
           ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
           ("M-g g" . consult-goto-line)             ;; orig. goto-line
           ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
           ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
           ("M-g m" . consult-mark)
           ("M-g k" . consult-global-mark)
           ("M-g i" . consult-imenu)
           ("M-g I" . consult-project-imenu)
           ;; M-s bindings (search-map)
           ("M-s f" . consult-find)
           ("M-s L" . consult-locate)
           ("M-s g" . consult-grep)
           ("M-s G" . consult-git-grep)
           ("M-s r" . consult-ripgrep)
           ("M-s l" . consult-line)
           ("M-s m" . consult-multi-occur)
           ("M-s k" . consult-keep-lines)
           ("M-s u" . consult-focus-lines)
           ;; Isearch integration
           ("M-s e" . consult-isearch-history)
           :map isearch-mode-map
           ("M-e" . consult-isearch-history)                 ;; orig. isearch-edit-string
           ("M-s e" . consult-isearch-history)               ;; orig. isearch-edit-string
           ("M-s l" . consult-line)))                 ;; needed by consult-line to detect isearch
#+end_src

** TODO Auto completetion
#+begin_src emacs-lisp
(use-package fancy-dabbrev
  :ensure t
  :config
  (global-fancy-dabbrev-mode)
  (global-set-key (kbd "TAB") 'fancy-dabbrev-expand-or-indent)
  (global-set-key (kbd "<backtab>") 'fancy-dabbrev-backward))
#+end_src

** Suggest next key
=which-key= suggests possible keys when pressing a key combination.
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :config
    (add-hook 'after-init-hook 'which-key-mode))
#+END_SRC

** Undo tree
Emacs let's you undo undo's, thanks to which the undo system is powerfull but sometimes quite complex.
=undo-tree= visualises the undo history to make it easier to navigate.
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :ensure t
    :defer 5
    :config
    (global-undo-tree-mode 1))
#+END_SRC

** Expand region
=expand-region= expands the selection region by semantic units.

As example:
    : (setq alphabet-start "abc def")
when the cursor is on c, =expand-region= will select the word, after that everything within quotes, after that including quotes, then everything within brackets, and then including brackets.

#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :bind
    (("C-=" . er/expand-region)
     ("C-+" . er/contract-region)
     :map mode-specific-map
     :prefix-map region-prefix-map
     :prefix "r"
     ("(" . er/mark-inside-pairs)
     (")" . er/mark-outside-pairs)
     ("'" . er/mark-inside-quotes)
     ([34] . er/mark-outside-quotes) ; it's just a quotation mark
     ("o" . er/mark-org-parent)
     ("u" . er/mark-url)
     ("b" . er/mark-org-code-block)
     ("." . er/mark-method-call)
     (">" . er/mark-next-accessor)
     ("w" . er/mark-word)
     ("d" . er/mark-defun)
     ("e" . er/mark-email)
     ("," . er/mark-symbol)
     ("<" . er/mark-symbol-with-prefix)
     (";" . er/mark-comment)
     ("s" . er/mark-sentence)
     ("S" . er/mark-text-sentence)
     ("p" . er/mark-paragraph)
     ("P" . er/mark-text-paragraph)))
#+END_SRC

** Snippets
TODO: explenation

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :disabled
    :config
    (add-to-list 'yas-snippet-dirs "~/.emacs.d/snippets")
    (yas-global-mode 1))

  (use-package yasnippet-snippets
    :ensure t)
#+END_SRC

** Modeline
Use =mood-line= package for a lightweight modline config.
#+begin_src emacs-lisp
  (use-package mood-line
    :config  
    (mood-line-mode))
#+end_src

Also show the battery level (helpfull with MacOS when Emacs is in full screen)
#+begin_src emacs-lisp
  (display-battery-mode 1)
#+end_src
** Prettify symbols
Enable =prettify-simbols= mode.
This will visually replace certain sets of characters by other characters (for example in elisp; lambda by λ)
#+begin_src emacs-lisp
  (global-prettify-symbols-mode 1)
#+end_src

** Better kill/yank
Define to, when killing/yanking without selection, kill or yank the entire line.
This is especially helpfull in god-mode to have vim-like short commands to kill or yank the current line.
#+begin_src emacs-lisp
  (defun slick-cut (beg end)
    (interactive
     (if mark-active
         (list (region-beginning) (region-end))
       (list (line-beginning-position) (line-beginning-position 2)))))

  (advice-add 'kill-region :before #'slick-cut)

  (defun slick-copy (beg end)
    (interactive
     (if mark-active
         (list (region-beginning) (region-end))
       (message "Copied line")
       (list (line-beginning-position) (line-beginning-position 2)))))

  (advice-add 'kill-ring-save :before #'slick-copy)
#+end_src

** DWIM (Do What I Mean)
In recent versions a "Do What I Mean" version was created for several commands.
With these commands, for example to convert to uppercase, the DWIM version will act on
the region if a region is selected, and on an appropriate semantic unit otherwise.
#+begin_src emacs-lisp
  (global-set-key (kbd "M-u") 'upcase-dwim)
  (global-set-key (kbd "M-l") 'downcase-dwim)
  (global-set-key (kbd "M-c") 'capitalize-dwim)
#+end_src

Also include comment-dwim-2 for some additional improvements (e.g. run multiple times
to switch between commenting the line and adding a comment after the line.
#+begin_src emacs-lisp
  (use-package comment-dwim-2
    :disabled t
    :ensure t
    :config
    (progn
      (global-set-key (kbd "M-;") 'comment-dwim-2)
      (define-key org-mode-map (kbd "M-;") 'org-comment-dwim-2)))
#+end_src
** Scratch buffer
Use org-mode as default mode for scratch buffer:
#+begin_src emacs-lisp
  (setq initial-major-mode 'org-mode)
#+end_src

Make scratch buffer persistent over emacs sessions:
#+begin_src emacs-lisp
  (defun save-persistent-scratch ()
    "Save the contents of *scratch*"
    (with-current-buffer (get-buffer-create "*scratch*")
      (write-region (point-min) (point-max)
                    (concat user-emacs-directory "scratch"))))

  (defun load-persistent-scratch ()
    "Reload the scratch buffer"
    (let ((scratch-file (concat user-emacs-directory "scratch")))
      (if (file-exists-p scratch-file)
          (with-current-buffer (get-buffer "*scratch*")
            (delete-region (point-min) (point-max))
            (insert-file-contents scratch-file)))))

  (add-hook 'emacs-startup-hook 'load-persistent-scratch)
  (add-hook 'kill-emacs-hook 'save-persistent-scratch)

  (run-with-idle-timer 300 t 'save-persistent-scratch)
#+end_src

Protect scratch buffer such that it can't accidentally be killed:
#+begin_src emacs-lisp
  (with-current-buffer "*scratch*"
    (emacs-lock-mode 'kill))
#+end_src
** Recent files
Setup emacs to use =C-x C-r= to show a list of recent files,
instead of opening a file as read-only.
#+begin_src emacs-lisp
  (recentf-mode 1)
  (setq recentf-max-menu-items 25)
  (setq recentf-max-saved-items 25)
  (global-set-key "\C-x\ \C-r" 'recentf-open-files)
#+end_src

** Line numbers
Normally the indentation/width of the left-side fringe with line numbers is dependent on the width of the line-number itself.
This is quite annoying in long, folded, files (e.g. org-files),
since this change in indentation makes it more difficult to compare indentation of things as headers.
This snippet will change the width of the fringe for all lines to the width of the last line,
such that the fringe is always indented equal across all lines.
#+begin_src emacs-lisp
  (defun display-line-numbers-equalize ()
    "Equalize The width"
    (setq display-line-numbers-width (length (number-to-string (line-number-at-pos (point-max))))))
  (add-hook 'find-file-hook 'display-line-numbers-equalize)
#+end_src

** File templates
Use build-in =auto-insert= package to automatically insert a filetype specific template when creating a new file.
#+begin_src emacs-lisp
  (use-package autoinsert
    :ensure t
    :init
    ;; Don't want to be prompted before insertion:
    (setq auto-insert-query nil)

    (setq auto-insert-directory (locate-user-emacs-file "templates"))

    (defun auto-insert-guard ()
      "Prevent auto-insertion for files that exist already"
      (interactive)
      (unless (file-exists-p (buffer-file-name))
        (auto-insert)))
    (add-hook 'find-file-hook 'auto-insert-guard)

    (auto-insert-mode 1)
    :config
    (defcustom auto-insert-init-form 'auto-insert-init-form
      "Symbol identifying init forms in template files."
      :group 'auto-insert
      :type 'symbol)

    (defun my-eval-auto-insert-init-form ()
      "Evaluate (AUTO-INSERT-INIT-FORM ...) in autoinsert templates.
    Thereby, AUTO-INSERT-INIT-FORM stands for the symbol defined by
    the customizable variable `auto-insert-init-form'.
    \(auto-insert-init-form ...) works like `progn'.
    Applied in the newly created file it should return the string
    that replaces the form."
      (goto-char (point-min))
      (cl-letf (((symbol-function auto-insert-init-form) #'progn))
        (while (re-search-forward "(auto-insert-init-form[[:space:]]" nil t)
          (let* ((beg (goto-char (match-beginning 0)))
                 (end (with-syntax-table emacs-lisp-mode-syntax-table
                        (forward-sexp)
                        (point)))
                 (str (eval (read (buffer-substring beg end)))))
            (delete-region beg end)
            (insert str)))))

    (define-auto-insert
      "\\.org?$"
      ["default-org.org"
       my-eval-auto-insert-init-form]))
#+end_src

** Buffer management
Use =ibuffer= package as replacement for =list-buffers= such that we can operate
on open buffers in a way similar to =dired=.
#+begin_src emacs-lisp
  (use-package ibuffer
    :bind
    ([remap list-buffers] . ibuffer))
#+end_src

** Auto close brackets
#+begin_src emacs-lisp
  (electric-pair-mode 1)
#+end_src>

* Org mode
#+begin_src emacs-lisp
;;;; general settings
(require 'org-tempo)
(setq org-startup-folded t)
(setq org-startup-indented 'f)
(setq org-special-ctrl-a/e 't)
(setq org-default-notes-file (concat org-directory "/notes.org"))
(defvar org-default-read-it-later-file (concat org-directory "/read_it_later.org"))
(define-key global-map "\C-cc" 'org-capture)
(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-ca" 'org-agenda)
(setq org-src-fontify-natively 't)
(setq org-src-tab-acts-natively 't)
(setq org-hide-emphasis-markers 't)
(setq org-todo-keywords
      '((sequence "TODO" "STARTED" "WAITING" "|" "DONE" "CANCELLED")))
(setq org-pretty-entities t)
(setq org-capture-templates
      '(
        ("t" "Todo" entry (file+headline org-default-notes-file "Inbox")
         "* TODO %^{TASK} %^g\n%^{DEADLINE}p%U\n%?" :empty-lines 1)
        ("n" "Note" entry (file+headline org-default-notes-file "Inbox")
         "* NOTE %?\n%U" :empty-lines 1)       
        ("b" "Bookmark URL" entry (file+olp org-default-notes-file "Bookmarks" "Unread")
         "* %(my-org-get-link-from-url) :bookmark:\n:PROPERTIES:\n:CREATED: %U\n:END:\n" :empty-lines 1)
        ))
(setq org-catch-invisible-edits 'show)
(setq org-use-sub-superscripts '{})

;; use org-mode for scratch buffer instead of elisp-mode
(setq initial-buffer-choice  org-default-notes-file)

;; quick hack to get company-mode autocomplete working with #+ blocks in org-mode
;; (defun trigger-org-company-complete ()
;;   "Begins company-complete in org-mode buffer after pressing #+ chars."
;;   (interactive)
;;   (if (string-equal "#" (string (preceding-char)))
;;       (progn
;;         (insert "+")
;;         (company-complete))
;;     (insert "+")))
;; (eval-after-load 'org '(define-key org-mode-map
;;                          (kbd "+") 'trigger-org-company-complete))

;; confige org-refile (C-x C-w) to allow refiling in subheaders
(setq org-refile-use-outline-path 'file)
(setq org-outline-path-complete-in-steps nil)
(setq org-refile-allow-creating-parent-nodes 'confirm)
(setq org-refile-targets ( quote (("notes.org" :maxlevel . 9))))

;; set max. inline image width, unless they have a with attribute
(setq org-image-actual-width '(700))


;;;; agenda
(setq org-agenda-window-setup 'current-window)
(setq org-agenda-start-day "-1d")
(setq org-agenda-span 10)
(setq org-agenda-start-on-weekday nil)


;;;; babel
(org-babel-do-load-languages
 'org-babel-load-languages
 '(
   (python . t)
   (C      . t)
   (matlab . t)
   (plantuml . t)
   (emacs-lisp . t)
   (lisp . t)
   (eshell . t)
   (calc . t)
   (shell . t)))
(setq org-confirm-babel-evaluate nil)
(setq org-src-window-setup 'current-window)
(setq org-edit-src-content-indentation 0)
(add-to-list 'org-babel-tangle-lang-exts '("matlab" . "m"))

;; function to update inline images after executing a babel code block.
;; this is helpfull for when a babel code block updates an image on disk
;; (mostly used with matlab, where matlab saves a figure to a file, which is linked to in org-mode)
(add-hook 'org-babel-after-execute-hook 'org-redisplay-inline-images)



;;;; export
;; When I tell Org-Mode to export to ODT at my day job, I actually want DOCX.
(setq org-odt-preferred-output-format "docx")
;; According to Chen Bin (http://blog.binchen.org/posts/how-to-take-screen-shot-for-business-people-efficiently-in-emacs.html),
;; the above should be sufficient on Linux, but he needed more setup on OSX. Let's see if I can adapt his code to Windows.
(defun config-org-export-as-docx-via-odt ()
  (interactive)
  (let ((cmd "C:/Program Files/LibreOffice/program/soffice.exe"))
    (when (and (eq system-type 'windows-nt) (file-exists-p cmd))
      ;; org v7
      (setq org-export-odt-convert-processes '(("LibreOffice" "\"C:\\Program Files\\LibreOffice\\program\\soffice.exe\" --headless --convert-to %f%x --outdir %d %i")))
      ;; org v8/v9
      (setq org-odt-convert-processes '(("LibreOffice" "\"C:\\Program Files\\LibreOffice\\program\\soffice.exe\" --headless --convert-to %f%x --outdir %d %i"))))
    ))
;; Run the function I just defined to set up org-export-as-docx-via-odt.
(config-org-export-as-docx-via-odt)

;; setup images to be embedded directly in html file instead of being linked to.
(defun org-html--format-image (source attributes info)
  (format "<img src=\"data:image/%s;base64,%s\"%s />"
          (or (file-name-extension source) "")
          (base64-encode-string
           (with-temp-buffer
             (insert-file-contents-literally source)
             (buffer-string)))
          (file-name-nondirectory source)))

(setq org-html-validation-link nil)
(setq org-html-htmlize-output-type 'css)


;;;; attachments
(setq org-attach-use-inheritance 't)


;;;; custom additions
;; define function (my-org-insert-link) to insert a link to an URL,
;; and to set the title of that link to the title of that webpage.
(require 'mm-url) ; to include mm-url-decode-entities-string

(defun my-org-insert-link ()
  "Insert org link where default description is set to html title."
  (interactive)
  (let* ((url (read-string "URL: "))
         (title (my-get-html-title-from-url url)))
    (org-insert-link nil url title)))

(defun my-get-html-title-from-url (url)
  "Return content in <title> tag."
  (let (x1 x2 (download-buffer (url-retrieve-synchronously url)))
    (with-current-buffer download-buffer
      (goto-char (point-min))
      (setq x1 (search-forward "<title>"))
      (search-forward "</title>")
      (setq x2 (search-backward "<"))
      (mm-url-decode-entities-string (buffer-substring-no-properties x1 x2)))))

(defun my-org-get-link-from-url ()
  "Return org-mode link where default description is set to html title."
  (interactive)
  (let* ((url (read-string "URL: "))
         (title (my-get-html-title-from-url url)))
    (concat "[[" url "][" title "]]")))
#+end_src

* Programming
** Generic
*** Auto completion
=company-mode= (Complete Anything) is used as autocomplete engine.
#+begin_src emacs-lisp
  (use-package company
    :disabled
    :ensure t
    :hook
    (after-init . global-company-mode))
#+end_src

#+begin_src emacs-lisp
  (use-package company-box
    :disabled
    :ensure t
    :hook
    (company-mode . company-box-mode)
    :custom
    (company-box-enable-icon nil)
    (company-box-max-candidates 50)
    (company-box-scrollbar nil)
    (company-box-show-single-candidate 'always))
#+end_src

*** Show function being written
In the modline, show the function being written:

#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook #'which-function-mode)
  (add-hook 'org-mode-hook  #'which-function-mode)
#+end_src

*** aggressive indent mode
mostly for elisp, but can be used for other languages

#+begin_src emacs-lisp
  (use-package aggressive-indent
    :ensure t
    :config
    (add-hook 'emacs-lisp-mode-hook #'aggressive-indent-mode)
    (add-hook 'lisp-mode-hook #'aggressive-indent-mode))
#+end_src

** Lisp
Always make sure that there are matching parens
#+begin_src emacs-lisp
  (add-hook 'emacs-lisp-mode-hook #'check-parens)
#+end_src

Highlight defined lisp symbols (when in elisp mode).
#+begin_src emacs-lisp
  (use-package highlight-defined
    :hook (emacs-lisp-mode . highlight-defined-mode))
#+end_src

Setup lispy, which is a vi-like mode for lisp editing.
#+begin_src emacs-lisp
  (use-package lispy
    :ensure t
    :config
    (progn (setq lispy-compat '(god-mode edebug))
           (add-hook 'emacs-lisp-mode-hook (lambda () (lispy-mode 1)))
           (add-hook 'lisp-mode-hook (lambda () (lispy-mode 1)))
           (defun conditionally-enable-lispy ()
             (when (eq this-command 'eval-expression)
               (lispy-mode 1)))
           (add-hook 'minibuffer-setup-hook 'conditionally-enable-lispy)))
#+end_src

** Python
*** Black
Black is an autoformatter for python code.
By installing =python-black= it can be ran automatically when a file is saved.

#+begin_src emacs-lisp
 (use-package python-black
   :after python
   :hook (python-mode . python-black-on-save-mode))
#+end_src

** MATLAB
*** Matlab REPL / Shell on Windows
Matlab doesn't provide a terminal/cmdline REPL in windows :(.
Therefore I've botched together a [[file:my_scripts/matlab_engine_repl.py][custom Matlab REPL]] in Python, with use of the Matlab-engine library from Mathworks.
Furthermore; I've used the Emacs comint (command-line interface) library to write a major mode for this REPL,
similar as to the elisp or python REPL's included in Emacs.
This Emacs REPL interface also includes support for MATLAB syntax highlighting.

Remark; the custom Matlab REPL doesn't support multi-line commands (yet?).

Comint code based on [[https://www.masteringemacs.org/article/comint-writing-command-interpreter][this masteringemacs article]].

#+begin_src emacs-lisp
  (defvar matlab-engine-repl-python-cli-interpreter "ipython"
    "Python interpreter used by `run-matlab-engine-repl'")

  (defvar matlab-engine-repl-script-path (expand-file-name "my_scripts/matlab_engine_repl.py")
    "Path to the python script used by `run-matlab-engine-repl'")

  (defvar matlab-engine-repl-python-cli-arguments `(,(subst-char-in-string ?/ ?\\ matlab-engine-repl-script-path) "")
    "Commandline arguments to pass to `matlab-engine-repl-cli'")
                                          ; remark: convert POSIX path of repl-script to windows backslashes

  (defvar matlab-engine-repl-mode-map
    (let ((map (nconc (make-sparse-keymap) comint-mode-map)))
      ;; example definition
      (define-key map "\t" 'completion-at-point)
      map)
    "Basic mode map for `run-matlab-engine-repl'")

  (defvar matlab-engine-repl-prompt-regexp "^>> "
    "Prompt for `run-matlab-engine-repl'.")

  (defun matlab-engine-repl ()
    "Run an inferior instance of `matlab-engine-repl-cli' inside Emacs."
    (interactive)
    (let* ((buffer (comint-check-proc "Matlab-engine REPL")))
      ;; pop to the "*Matlab-Engine-Repl*" buffer if the process is dead, the
      ;; buffer is missing or it's got the wrong mode.
      (pop-to-buffer-same-window
       (if (or buffer (not (derived-mode-p 'matlab-engine-repl-mode))
               (comint-check-proc (current-buffer)))
           (get-buffer-create (or buffer "*Matlab-engine REPL*"))
         (current-buffer)))
      ;; create the comint process if there is no buffer.
      (unless buffer
        (apply 'make-comint-in-buffer "Matlab-engine REPL" buffer
               matlab-engine-repl-python-cli-interpreter nil matlab-engine-repl-python-cli-arguments)
        (matlab-engine-repl-mode))))

  (defun matlab-engine-repl--initialize ()
    "Helper function to initialize Matlab-Engine-Repl"
    (setq comint-process-echoes t)
    (setq comint-use-prompt-regexp t))

  (define-derived-mode matlab-engine-repl-mode comint-mode "Matlab-engine REPL"
    "Major mode for `run-matlab-engine-repl'."
    :syntax-table matlab-mode-syntax-table
    nil "Matlab-engine REPL"
    ;; this sets up the prompt so it matches the repl prompt (e.g. ">> ")
    (setq comint-prompt-regexp matlab-engine-repl-prompt-regexp)
    ;; this makes it read only; a contentious subject as some prefer the
    ;; buffer to be overwritable.
    (setq comint-prompt-read-only t)
    ;; this makes it so commands like M-{ and M-} work.
    ;(set (make-local-variable 'paragraph-separate) ">> ")
    (set (make-local-variable 'font-lock-defaults) '(matlab-font-lock-keywords t))
    (set (make-local-variable 'paragraph-start) matlab-engine-repl-prompt-regexp))

  ;; this has to be done in a hook. grumble grumble.
  (add-hook 'matlab-engine-repl-mode-hook 'matlab-engine-repl--initialize)
#+end_src

This script also has a command line option for org-babel.
When this is used the program will not run in a while loop,
but will just wait until it receives an EOF and then evaluate the entire input.
This causes multi-line inputs, e.g. if/else loops or similar where only a single line gives an syntax error,
to be correctly evaluated.
We only have to change the org-babel command for ob-matlab to this script including the command line parameter.
Remark; in contradiction to the comint interface we can just run it in standard python (which is done by default when we directly try to execute a .py file).
#+begin_src emacs-lisp
  (setq org-babel-matlab-shell-command (concat (expand-file-name "my_scripts/matlab_engine_repl.py") " --orgbabel"))
#+end_src

** Julia
#+begin_src emacs-lisp
  (use-package julia-mode)
#+end_src

* Other
** Calc
Emacs calc can work with units, and also simplify them (math-convert-units).
However; this function is not defined for use in inline math (as is the case for the unit simplification function usimplify()).
Define our own inline math function which calls math-convert-units such that we can also convert units using inline math.
This is especially helpfull when, for example, performing embedded calc calculations in an org mode document.
#+begin_src emacs-lisp
  (defmath uconvert (v u)
    "Convert value V to compatible unit U."
    (math-convert-units v u))
#+end_src

Define both an inline math and interactive user function to perform the "parallel" calculation (1/(1/x)+(1/y)+(1/...)).
The interactive function is bound to z-p within calc-mode.
#+begin_src emacs-lisp
  (defun calcFunc-parallel (v)
    "Calculate parallel value of the elements in vector v (as if each element is a resistance, capacitance, etc.)."
    (math-simplify-units (math-div 1
                                   (calcFunc-vsum(math-map-vec (lambda (x) (math-div 1 x)) v)))))

  (put 'calc-define 'calc-User-parallel '(progn
   (defun calc-User-parallel (arg) (interactive "P")
    (calcFunc-parallel arg)
   (put 'calc-User-parallel 'calc-user-defn 't)
   (define-key calc-mode-map "zp" 'calc-User-parallel)
  )))

#+end_src

** Dired
#+begin_src emacs-lisp
  (setq dired-dwim-target t)
  (setq delete-by-moving-to-trash t)
#+end_src

** Custom Tools
*** Excel remove sheet protection
I've written a small emacs function which removes the sheet-protection of an MS Excel file.
#+begin_src emacs-lisp
  (load "~/.emacs.d/my_el/excel-remove-sheet-protection.el")
#+end_src

** Search / replace
Bride the functionalities from =re-builder= and =*-replace-regexp= such that regular expressions can be made using =re-builder= and directly used as input for =*-replace-regexp=.
See [[https://karthinks.com/software/bridging-islands-in-emacs-1/]] for additional reference.

Very briefly, the code works as follows:
- Save the region and point positions into my/re-builder-positions before invoking re-builder, since these are lost.
  This is done by advising the function.
- When you press RET, quit re-builder and call qrr with the built regexp, saved point and region information.

Lastly, if you want to insert a newline in the regexp-builder buffer you can now use C-q C-j.
Entering literal newlines in a regexp definition is rare enough that dedicating RET to the much more useful qrr is a no-brainer.

#+begin_src emacs-lisp
  (require 're-builder)
  (setq reb-re-syntax 'string)

  (defvar my/re-builder-positions nil
    "Store point and region bounds before calling re-builder")

  (advice-add 're-builder
              :before
              (defun my/re-builder-save-state (&rest _)
                "Save into `my/re-builder-positions' the point and region positions before calling `re-builder'."
                (setq my/re-builder-positions
                      (cons (point)
                            (when (region-active-p)
                              (list (region-beginning)
                                    (region-end)))))))

  (defun reb-replace-regexp (&optional delimited)
    "Run `query-replace-regexp' with the contents of re-builder. With
  non-nil optional argument DELIMITED, only replace matches
  surrounded by word boundaries."
    (interactive "P")
    (reb-update-regexp)
    (let* ((re (reb-target-binding reb-regexp))
           (replacement (query-replace-read-to
                         re
                         (concat "Query replace"
                                 (if current-prefix-arg
                                     (if (eq current-prefix-arg '-) " backward" " word")
                                   "")
                                 " regexp"
                                 (if (with-selected-window reb-target-window
                                       (region-active-p)) " in region" ""))
                         t))
           (pnt (car my/re-builder-positions))
           (beg (cadr my/re-builder-positions))
           (end (caddr my/re-builder-positions)))
      (with-selected-window reb-target-window
        (goto-char pnt) ; replace with (goto-char (match-beginning 0)) if you want
                        ; to control where in the buffer the replacement starts
                        ; with re-builder
        (setq my/re-builder-positions nil)
        (reb-quit)
        (query-replace-regexp re replacement delimited beg end))))

  (define-key reb-mode-map (kbd "RET") #'reb-replace-regexp)
  (define-key reb-lisp-mode-map (kbd "RET") #'reb-replace-regexp)
  (global-set-key (kbd "C-M-%") #'re-builder)
#+end_src
** Ereader
Use ereader package for Emacs to be able to open ebooks.
#+begin_src emacs-lisp
  (use-package ereader
    :ensure t)
#+end_src

** RSS (newsticker)
#+begin_src emacs-lisp
  (global-set-key (kbd "C-x w") 'newsticker-treeview) 
#+end_src

** Try
[[http://github.com/larstvei/try][Try]] new packages without installing them.
#+begin_src emacs-lisp
  (use-package try
    :ensure t
    :defer t)
#+end_src
** Magit
#+begin_src emacs-lisp
  (use-package magit
    :ensure t
    :bind (("C-x g" . 'magit-status)))
#+end_src

** Tramp
#+begin_src emacs-lisp
(setq tramp-default-method "ssh")
#+end_src
* Finxfalizers
Reset debugger information
#+begin_src emacs-lisp
  (setq debug-on-error nil)
  (setq debug-on-quit nil)
#+end_src


